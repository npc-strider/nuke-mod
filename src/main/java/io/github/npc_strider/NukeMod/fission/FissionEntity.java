package io.github.npc_strider.NukeMod.fission;

import org.jetbrains.annotations.Nullable;

import io.github.npc_strider.NukeMod.NukeMod;
import io.github.npc_strider.NukeMod.NukeModClient;
import io.github.npc_strider.NukeMod.entity.FastExplosion;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityDimensions;
import net.minecraft.entity.EntityPose;
import net.minecraft.entity.EntityType;
import net.minecraft.entity.LivingEntity;
import net.minecraft.entity.MovementType;
import net.minecraft.entity.TntEntity;
import net.minecraft.entity.data.DataTracker;
import net.minecraft.entity.data.TrackedData;
import net.minecraft.entity.data.TrackedDataHandlerRegistry;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.network.Packet;
import net.minecraft.network.packet.s2c.play.EntitySpawnS2CPacket;
import net.minecraft.sound.SoundCategory;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.World;

public class FissionEntity extends Entity {		// I frankly don't have time to mess about with extending TntEntity - just CTRL+C'd it
    
    private static final int FUSE_TIMER = 20*15; //Ticks

    private static final TrackedData<Integer> FUSE;
    @Nullable
    private LivingEntity causingEntity;
    private int fuseTimer;

    // private double RADIUS_X = 16;
    private double RADIUS_X = 60;
    private double RADIUS_Z = RADIUS_X;   //Keep these the same!
    // private double RADIUS_Y = 16;   //I keep forgetting that minecraft vectors are weird and Z isn't the vertical axis...
    private double RADIUS_Y = 96;   //I keep forgetting that minecraft vectors are weird and Z isn't the vertical axis...
    private Vec3d radius = new Vec3d(RADIUS_X, RADIUS_Y, RADIUS_Z);

    private double EFFECT_FACTOR = 3; //This is the radius to which effects such as radiation, vaporization and glassification occur.z
    private Vec3d effectRadius = new Vec3d(Math.floor(RADIUS_X*EFFECT_FACTOR), Math.floor(RADIUS_Y*EFFECT_FACTOR), Math.floor(RADIUS_Z*EFFECT_FACTOR));

    // public FissionEntity(World world, double x, double y, double z, @Nullable LivingEntity igniter) {

    protected FissionEntity(World world, double x, double y, double z, @Nullable LivingEntity igniter) {
		this(NukeMod.FISSION_ENTITY, world);
		this.updatePosition(x, y, z);
		double d = world.random.nextDouble() * 6.2831854820251465D;
		this.setVelocity(-Math.sin(d) * 0.02D, 0.20000000298023224D, -Math.cos(d) * 0.02D);
		this.prevX = x;
		this.prevY = y+5;
		this.prevZ = z;
		this.causingEntity = igniter;
		// this(NukeMod.FISSION_ENTITY, world);
		// super(world, x, y, z, igniter);	//This calls the super implementation which results in the wrong tick method being used.
		this.fuseTimer = FUSE_TIMER;
		this.setFuse(FUSE_TIMER);
	}

	public FissionEntity(@Nullable EntityType<? extends FissionEntity> entityType, World world) {
		super(entityType != null ? entityType : NukeMod.FISSION_ENTITY, world);
		this.fuseTimer = FUSE_TIMER;
		this.inanimate = true;
    }

	@Override
	public void tick() {
		if (!this.hasNoGravity()) {
			this.setVelocity(this.getVelocity().add(0.0D, -0.04D, 0.0D));
		}
	
		this.move(MovementType.SELF, this.getVelocity());
		this.setVelocity(this.getVelocity().multiply(0.98D));
		if (this.onGround) {
			this.setVelocity(this.getVelocity().multiply(0.7D, -0.5D, 0.7D));
		}
	
		--this.fuseTimer;
		if (this.fuseTimer <= 0) {
			this.remove();
			this.explode();
			// if (!this.world.isClient) {
			// 	this.explode(new Vec3d(this.getX(), this.getY(), this.getZ()), this.RADIUS_X, this.RADIUS_Y, this.RADIUS_Z);
			// }
		} else {
			this.updateWaterState();
			// System.out.println(this.world.isClient);
			if (this.world.isClient) {
				double x = this.getX();
				double y = this.getY();
				double z = this.getZ();
				Vec3d v = this.getVelocity();
				double vx = v.getX();
				double vy = v.getY();
				double vz = v.getZ();
				for (int i = 0; i < 4; i++) {
					spawnAlphaParticles(x, y, z, vx, vy, vz);
				}
				// this.world.addParticle(ParticleTypes.SMOKE, this.getX(), this.getY() + 0.5D, this.getZ(), 0.0D, 0.0D, 0.0D);
			}
			if (this.fuseTimer % 60 == 0 || this.fuseTimer == FUSE_TIMER - 1) {
				world.playSound((PlayerEntity)null, this.getX(), this.getY(), this.getZ(), NukeMod.FISSION_ALARM, SoundCategory.BLOCKS, 15.0F, 1.0F);
			}
		}
	}

    //Why use a custom explosion ?
    //Because the vanilla method uses raytracing which works well for small explosions but does not scale to large explosions due to a limited number of rays.
    //Also, raytracing is compartively more expensive/costly, which is evident by the lag generated by large explosions.
    private void explode() {
		//Vanilla method - small explosion // this.world.createExplosion(this, this.getX(), this.getBodyY(0.0625D), this.getZ(), 200.0F, Explosion.DestructionType.DESTROY);
		FastExplosion explosion = new FastExplosion(this, radius, effectRadius, this.getPos(), this.world);
		explosion.damageBlocksAndEntities();
	}

	private void spawnAlphaParticles(double x, double y, double z, double vx, double vy, double vz) {
		this.world.addParticle(
			NukeModClient.FISSION_PARTICLE,
			true,
			x + 0.0D + (random.nextDouble() - 0.5D) * 0.2D,
			y + 0.7D + (random.nextDouble() - 0.5D) * 0.2D,
			z + 0.0D + (random.nextDouble() - 0.5D) * 0.2D,
			vx + (random.nextDouble() - 0.5D) * 0.25F,
			vy + (random.nextDouble() - 0.0D) * 0.25F,
			vz + (random.nextDouble() - 0.5D) * 0.25F
		);
	}

	protected void initDataTracker() {
	   this.dataTracker.startTracking(FUSE, 80);
	}
 
	protected boolean canClimb() {
	   return false;
	}
 
	public boolean collides() {
	   return !this.removed;
	}
 
	protected void writeCustomDataToTag(CompoundTag tag) {
		tag.putShort("Fuse", (short)this.getFuseTimer());
	}

	protected void readCustomDataFromTag(CompoundTag tag) {
		this.setFuse(tag.getShort("Fuse"));
	}

	@Nullable
	public LivingEntity getCausingEntity() {
		return this.causingEntity;
	}

	protected float getEyeHeight(EntityPose pose, EntityDimensions dimensions) {
		return 0.15F;
	}
  
	public void setFuse(int fuse) {
		this.dataTracker.set(FUSE, fuse);
		this.fuseTimer = fuse;
	}

	public void onTrackedDataSet(TrackedData<?> data) {
		if (FUSE.equals(data)) {
		this.fuseTimer = this.getFuse();
		}
	}

	public int getFuse() {
		return (Integer)this.dataTracker.get(FUSE);
	}

	public int getFuseTimer() {
		return this.fuseTimer;
	}

	public Packet<?> createSpawnPacket() {
		return new EntitySpawnS2CPacket(this);
	}

	static {
		FUSE = DataTracker.registerData(TntEntity.class, TrackedDataHandlerRegistry.INTEGER);
	}
}
